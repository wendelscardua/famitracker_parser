require 'famitracker_parser/song'

grammar FamitrackerTextGrammar
  rule song
    export_description linebreak
    song_information linebreak
    song_comment linebreak
    global_settings linebreak
    macros linebreak
    dpcm_samples linebreak
    (dn_detune_settings linebreak)?
    (dn_grooves linebreak)?
    instruments linebreak
    tracks
    "# End of export"
    linebreak
    {
      def value
        FamitrackerParser::Song.new.tap do |song|
          song.export_description = export_description.value
          song.song_information = song_information.value
          song.song_comment = song_comment.value
          song.global_settings = global_settings.value
          song.macros = macros.value
          song.dpcm_samples = dpcm_samples.value
          song.instruments = instruments.value
          song.tracks = tracks.value
        end
      end
    }
  end

  rule export_description
    "# " program:([^\s]*) " text export " version:([^\r\n]*) linebreak
    {
      def value
        FamitrackerParser::ExportDescription.new.tap do |export_description|
          export_description.program = program.text_value
          export_description.version = version.text_value
        end
      end
    }
  end

  rule song_information
    "# Song information" linebreak
    "TITLE" spaces title:string linebreak
    "AUTHOR" spaces author:string linebreak
    "COPYRIGHT" spaces copyright:string linebreak
    {
      def value
        FamitrackerParser::SongInformation.new.tap do |song_information|
          song_information.title = title.value
          song_information.author = author.value
          song_information.copyright = copyright.value
        end
      end
    }
  end

  rule song_comment
    "# Song comment" linebreak
    "COMMENT" spaces comment:string linebreak
    {
      def value
        comment.value
      end
    }
  end

  rule global_settings
    "# Global settings" linebreak
    "MACHINE" spaces machine:integer linebreak
    "FRAMERATE" spaces framerate:integer linebreak
    "EXPANSION" spaces expansion:integer linebreak
    "VIBRATO" spaces vibrato:integer linebreak
    "SPLIT" spaces split:integer linebreak
    n163_gs:(
      linebreak "# Namco 163 global settings" linebreak
      "N163CHANNELS" spaces n163_channels:integer linebreak
    )?
    {
      def value
        FamitrackerParser::GlobalSettings.new.tap do |global_settings|
          global_settings.machine = machine.value
          global_settings.framerate = framerate.value
          global_settings.expansion = expansion.value
          global_settings.vibrato = vibrato.value
          global_settings.split = split.value
          global_settings.n163_channels = n163_gs.n163_channels.value if n163_gs.elements
        end
      end
    }
  end

  rule macros
    "# Macros" linebreak
    macros:(macro)*
    {
      def value
        macros.elements.map(&:value)
      end
    }
  end

  rule macro
    "MACRO"
    spaces type:integer
    spaces id:integer
    spaces loop_index:integer
    spaces release_index:integer
    spaces arpeggio_type:integer
    spaces ":"
    values:(spaces integer)+
    linebreak
    {
      def value
        FamitrackerParser::Macro.new.tap do |macro|
          macro.type = type.value
          macro.id = id.value
          macro.loop_index = loop_index.value
          macro.release_index = release_index.value
          macro.arpeggio_type = arpeggio_type.value
          macro.values = values.elements.map(&:integer).map(&:value)
        end
      end
    }
  end

  rule dpcm_samples
    "# DPCM samples" linebreak
    dpcm_samples:(dpcm_sample)*
    {
      def value
        dpcm_samples.elements.map(&:value)
      end
    }
  end

  rule dpcm_sample
    "DPCMDEF" spaces id:integer spaces size:integer spaces name:string linebreak
    dpcm_bytes:("DPCM" spaces ":" bytes:(spaces byte:hexadecimal_byte)+ linebreak)*
    {
      def value
        FamitrackerParser::DPCMSample.new.tap do |dpcm_sample|
          dpcm_sample.id = id.value
          dpcm_sample.size = size.value
          dpcm_sample.name = name.value
          dpcm_sample.bytes = dpcm_bytes.elements.flat_map(&:bytes).flat_map(&:elements).flat_map(&:byte).map(&:value)
        end
      end
    }
  end

  # Dn-Famitracker specific settings
  # (TODO)
  rule dn_detune_settings
    "# Detune settings" linebreak
  end

  # Dn-Famitracker grooves
  # (TODO)
  rule dn_grooves
    "# Grooves" linebreak
    ("GROOVE" spaces integer spaces integer spaces ":" values:(spaces value:integer)+ linebreak)+
    linebreak
    "# Tracks using default groove" linebreak
    "USEGROOVE" spaces ":" default_tracks:(spaces track:integer)+ linebreak
  end

  rule instruments
    "# Instruments" linebreak
    instruments:(instrument)*
    {
      def value
        instruments.elements.map(&:value)
      end
    }
  end

  rule instrument
    type:("INST2A03")
    spaces id:integer
    spaces volume_macro:integer
    spaces arpeggio_macro:integer
    spaces pitch_macro:integer
    spaces hi_pitch_macro:integer
    spaces duty_noise_macro:integer
    spaces name:string
    linebreak
    dpcm_keys:(dpcm_keys)*
    {
      def value
        FamitrackerParser::Instrument.new.tap do |instrument|
          instrument.type = type.text_value
          instrument.id = id.value
          instrument.volume_macro = volume_macro.value
          instrument.arpeggio_macro = arpeggio_macro.value
          instrument.pitch_macro = pitch_macro.value
          instrument.hi_pitch_macro = hi_pitch_macro.value
          instrument.duty_noise_macro = duty_noise_macro.value
          instrument.name = name.value
          instrument.dpcm_keys = dpcm_keys.elements.map(&:value)
        end
      end
    }
  end

  rule dpcm_keys
    "KEYDPCM"
    spaces instrument_id:integer
    spaces octave:integer
    spaces note:integer
    spaces dpcm_sample_id:integer
    spaces pitch:integer
    spaces loop:integer
    spaces "0"
    spaces d_counter:integer
    linebreak
    {
      def value
        FamitrackerParser::DPCMKey.new.tap do |dpcm_key|
          dpcm_key.octave = octave.value
          dpcm_key.note = note.value
          dpcm_key.dpcm_sample_id = dpcm_sample_id.value
          dpcm_key.pitch = pitch.value
          dpcm_key.loop = loop.value
          dpcm_key.d_counter = d_counter.value
        end
      end
    }
  end

  rule tracks
    "# Tracks" linebreak linebreak
    tracks:(track)*
    {
      def value
        tracks.elements.map(&:value)
      end
    }
  end

  rule track
    "TRACK"
    spaces rows:integer
    spaces speed:integer
    spaces tempo:integer
    spaces name:string
    linebreak
    "COLUMNS" spaces ":" (spaces integer)* linebreak
    linebreak
    pattern_order:(order_row)*
    linebreak
    patterns:(pattern linebreak)*
    {
      def value
        FamitrackerParser::Track.new.tap do |track|
          track.rows = rows.value
          track.speed = speed.value
          track.tempo = tempo.value
          track.name = name.value
          track.pattern_order = pattern_order.elements.map(&:value)
          track.patterns = patterns.elements.map(&:pattern).map(&:value)
        end
      end
    }
  end

  rule order_row
    "ORDER" spaces index:hexadecimal_byte spaces ":"
    bytes:(spaces byte:hexadecimal_byte)* linebreak
    {
      def value
        bytes.elements.map(&:byte).map(&:value)
      end
    }
  end

  rule pattern
    "PATTERN" spaces id:hexadecimal_byte linebreak
    rows:(row)*
    {
      def value
        FamitrackerParser::Pattern.new.tap do |pattern|
          pattern.id = id.value
          pattern.rows = rows.elements.map(&:value)
        end
      end
    }
  end

  rule row
    "ROW"
    spaces id:hexadecimal_byte
    row_channels:(" : " row_channel)+
    linebreak
    {
      def value
        FamitrackerParser::Row.new.tap do |row|
          row.id = id.value
          row.channels = row_channels.elements.map(&:row_channel).map(&:value)
        end
      end
    }
  end

  rule row_channel
    note_octave " " rc_instrument " " volume effects:(" " effect)+
    {
      def value
        FamitrackerParser::RowChannel.new.tap do |row_channel|
          row_channel.note_octave = note_octave.value
          row_channel.instrument = rc_instrument.value
          row_channel.volume = volume.value
          row_channel.effects = effects.elements.map(&:effect).map(&:value)
        end
      end
    }
  end

  rule note_octave
    (
      "..."
      /
      "---"
      /
      "==="
      /
      [0-9ABCDEFG] [-#] [0-9#]
    )
    {
      def value
        text_value == "..." ? nil : text_value
      end
    }
  end

  rule rc_instrument
    byte:hexadecimal_byte
    {
      def value
        byte.value
      end
    }
    /
    ".."
    {
      def value
        nil
      end
    }
  end

  rule volume
    nibble:hexadecimal_nibble
    {
      def value
        nibble.value
      end
    }
    /
    "."
    {
      def value
        nil
      end
    }
  end

  rule effect
    "..."
    {
      def value
        nil
      end
    }
    /
    (command:[0-9A-Z] argument:hexadecimal_byte)
    {
      def value
        FamitrackerParser::Effect.new.tap do |effect|
          effect.command = command.text_value
          effect.argument = argument.value
        end
      end
    }
  end

  rule linebreak
    "\r\n"
  end

  rule spaces
    [\s]+
  end

  rule string
    '"' string_value:(('\"' / !'"' .)*) '"'
    {
      def value
        string_value.text_value
      end
    }
  end

  rule integer
    [-]? [0-9]+
    {
      def value
        text_value.to_i
      end
    }
  end

  rule hexadecimal_byte
    [0-9A-F] [0-9A-F]
    {
      def value
        text_value.to_i(16)
      end
    }
  end

  rule hexadecimal_nibble
    [0-9A-F]
    {
      def value
        text_value.to_i(16)
      end
    }
  end
end
